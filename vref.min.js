export default e=>new s(e);const e=Symbol();class s{#e=[];constructor(e){this[0]=e}get value(){return this[0]}set value(s){this[0]=s;for(let r of this.#e)"function"==typeof r[e]&&r[e](),r.next&&(r[e]=r.next(s))}valueOf(){return this.value}toString(){return this.value}[Symbol.toPrimitive](e){return this.value}subscribe(s,r,t){const o=()=>(this.#e.length&&this.#e.splice(this.#e.indexOf(i)>>>0,1),t&&t()),i={next:s=s&&s.next||s,error:r=s&&s.error||r,complete:t=s&&s.complete||t,unsubscribe:o};return this.#e.push(i),void 0!==this[0]&&(i[e]=s(this[0])),o.unsubscribe=o}map(e){const r=new s;return this.subscribe((s=>r.value=e(s))),r}error(e){this.#e.map((s=>s.error&&s.error(e)))}[Symbol.observable](){return this}async*[Symbol.asyncIterator](){let e,s=[],r=new Promise((s=>e=s)),t=this.subscribe((t=>(s.push(t),e(),r=new Promise((s=>e=s)))));try{for(;;)yield*s.splice(0),await r}catch{}t()}dispose(){this[0]=null;const s=this.#e.map((s=>("function"==typeof s[e]&&s[e](),s.unsubscribe)));this.#e.length=0,s.map((e=>e()))}[Symbol.dispose](){return this.dispose()}}