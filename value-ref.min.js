export default e=>new s(e);class s{#s=[];constructor(s){this[0]=s}get value(){return this[0]}set value(s){this[0]=s;for(let e of this.#s)e[4]?.call?.(),e[4]=e[0]?.(s)}valueOf(){return this.value}toString(){return this.value}[Symbol.toPrimitive](s){return this.value}subscribe(s,e,r){const t=()=>(this.#s.length&&this.#s.splice(this.#s.indexOf(i)>>>0,1),r?.()),i=[s=s?.next||s,e=s?.error||e,r=s?.complete||r,t];return this.#s.push(i),void 0!==this[0]&&(i[4]=s(this[0])),t.unsubscribe=t}map(e){const r=new s;return this.subscribe((s=>r.value=e(s))),r}error(s){this.#s.map((e=>e[1]?.(s)))}[Symbol.observable||=Symbol.for("observable")](){return this}async*[Symbol.asyncIterator](){let s,e=[],r=new Promise((e=>s=e)),t=this.subscribe((t=>(e.push(t),s(),r=new Promise((e=>s=e)))));try{for(;;)yield*e.splice(0),await r}catch{}t()}dispose(){this[0]=null;const s=this.#s.map((s=>(s[4]?.call?.(),s[3])));this.#s.length=0,s.map((s=>s()))}[Symbol.dispose||=Symbol("dispose")](){return this.dispose()}}